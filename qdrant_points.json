{"result":{"points":[{"id":"0c9174ad-5d23-4b9c-88af-0e022c65cff2","payload":{"content":"Output: \n \n \n \n \n \n \n \n \n \n \n \n\n \nLab 5: C- program to implement first of a given grammar \n \n#include <stdio.h> \n#include <ctype.h> \nvoid FIRST(char[], char); \nvoid addToResultSet(char[], char); \nint numOfProductions; \nchar productionSet[10][10]; \nint main() \n{ \n    int i; \n    char choice; \n    char c; \n    char result[20]; \n    printf(\"How many number of productions ? :\"); \n    scanf(\" %d\", &numOfProductions); \n    for (i = 0; i < numOfProductions; i++) // read production string e.g.: E=E+T \n    { \n        printf(\"Enter productions Number %d : \", i + 1); \n        scanf(\" %s\", productionSet[i]); \n    } \n    do \n    { \n        printf(\"\\n Find the FIRST of :\"); \n        scanf(\" %c\", &c); \n        FIRST(result, c); // Compute FIRST; Get Answer in 'result' array \n        printf(\"\\n FIRST(%c)= { \", c); \n        for (i = 0; result[i] != '\\0'; i++) \n            printf(\" %c \", result[i]); // Display result","metadata":{"loc":{"lines":{"from":267,"to":309}}}}},{"id":"0dc1b232-fd52-4be7-884a-dfd7679ac8b6","payload":{"content":"Lab 10: C-program for Final Code Generation \n#include <stdio.h> \n#include <string.h> \nchar op[2], arg1[5], arg2[5], result[5]; \nint main() \n{ \n    FILE *fp1, *fp2; \n    fp1 = fopen(\"input2.txt\", \"r\"); \n    fp2 = fopen(\"output2.txt\", \"w\"); \n    while (!feof(fp1)) \n    { \n        fscanf(fp1, \"%s%s%s%s\", op, arg1, arg2, result); \n        if (strcmp(op, \"+\") == 0) \n        { \n            fprintf(fp2, \"\\n MOV R0,%s\", arg1); \n            fprintf(fp2, \"\\n ADD R0,%s\", arg2); \n            fprintf(fp2, \"\\n MOV %s,R0\", result); \n        } \n        if (strcmp(op, \"*\") == 0) \n        { \n            fprintf(fp2, \"\\n MOV R0,%s\", arg1); \n            fprintf(fp2, \"\\n MUL R0,%s\", arg2); \n            fprintf(fp2, \"\\n MOV %s, R0\", result); \n        } \n        if (strcmp(op, \"-\") == 0) \n        { \n            fprintf(fp2, \"\\n MOV R0,%s\", arg1); \n            fprintf(fp2, \"\\n SUB R0,%s\", arg2); \n            fprintf(fp2, \"\\n MOV %s,R0\", result); \n        }","metadata":{"loc":{"lines":{"from":842,"to":871}}}}},{"id":"20872b30-7b39-4ef8-8c98-aebdec78a1ee","payload":{"content":"else \n        printf(\"\\n%s is not recognized\", s); \n    return 0; \n} \n \nOutput :  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \nLab 3: Write a C program to test whether a given identifier is valid or not \n#include <stdio.h> \n#include <conio.h> \n#include <ctype.h> \nint main() \n{ \n    char a[10]; \n    int flag, i = 1; \n    printf(\"\\n Enter an identifier:\"); \n    gets(a); \n    if (isalpha(a[0]) || a[0] == '_') \n        flag = 1; \n    else \n        printf(\"\\n Not a valid identifier\"); \n    while (a[i] != '\\0') \n    { \n        if (!isdigit(a[i]) && !isalpha(a[i]) && a[i] != '_') \n        { \n            flag = 0; \n            break; \n        } \n        i++; \n    } \n    if (flag == 1) \n        printf(\"\\n Valid identifier\"); \n    else \n        printf(\"Not a valid identifier\"); \n\n \n    return 0; \n} \n \nOutput:","metadata":{"loc":{"lines":{"from":121,"to":180}}}}},{"id":"2245f9c4-3329-4734-9a94-fd40c0dac868","payload":{"content":"Result[k] = val; \n    Result[k + 1] = '\\0'; \n} \n \nOutput : \n \n \n \n \n \n \n \n \n \n \n \n \n\n \nLab 6: C-Program to calculate follow of given grammar \n \n #include <stdio.h> \n#include <string.h> \n#include <ctype.h> \nint n, p, i = 0, j = 0; \nchar a[10][10], Result[10]; \nchar subResult[20]; \nvoid follow(char *Result, char c); \nvoid first(char *Result, char c); \nvoid addToResultSet(char[], char); \nint main() \n{ \n    int i; \n    int choice; \n    char c, ch; \n    printf(\"Enter the no. of productions: \"); \n    scanf(\"%d\", &n); \n    printf(\" Enter %d productions\\n Production with multiple terms should be give as separate \nproductions \\n\", n); \n    for (i = 0; i < n; i++) \n        scanf(\"%s\", a[i]); \n    do \n    { \n        printf(\"Find FOLLOW of -->\"); \n        scanf(\" %c\", &c); \n        follow(Result, c); \n        printf(\"FOLLOW(%c) = { \", c); \n        for (i = 0; Result[i] != '\\0'; i++) \n            printf(\" %c \", Result[i]);","metadata":{"loc":{"lines":{"from":376,"to":424}}}}},{"id":"2b9b1ef1-bc07-4257-b92b-62890e9e3a96","payload":{"content":"{ \n        case 'e': \n            str1 = 0; \n            break; \n        case 'b': \n            str1 = 1; \n            break; \n        case 't': \n            str1 = 2; \n            break; \n        case 'c': \n            str1 = 3; \n            break; \n        case 'f': \n            str1 = 4; \n            break; \n        } \n        switch (s[j]) \n        { \n        case 'i': \n            str2 = 0; \n            break; \n        case '+': \n            str2 = 1; \n            break; \n        case '*': \n            str2 = 2; \n            break; \n        case '(': \n            str2 = 3;","metadata":{"loc":{"lines":{"from":520,"to":549}}}}},{"id":"36753115-b856-4b65-9e92-5a31d1813e96","payload":{"content":"printf(\"}\\n\"); \n        printf(\"press 'y' to continue : \"); \n        scanf(\" %c\", &choice); \n    } while (choice == 'y' || choice == 'Y'); \n} \nvoid FIRST(char *Result, char c) \n{ \n    int i, j, k; \n    char subResult[20]; \n    int foundEpsilon; \n    subResult[0] = '\\0'; \n    Result[0] = '\\0'; \n    // If X is terminal, FIRST(X) = {X} \n    if (!(isupper(c))) \n    { \n        addToResultSet(Result, c); \n        return; \n    } \n    // If X is non terminal then read each production \n    for (i = 0; i < numOfProductions; i++) \n    { \n        // Find production with X as LHS \n        if (productionSet[i][0] == c) \n        { \n            if (productionSet[i][2] == '$') \n                addToResultSet(Result, '$'); \n            // If X is a non-terminal, and X â†’ Y1 Y2 â€¦ Yk is a production, then add ato FIRST(X)  \n            else \n            { \n                j = 2;","metadata":{"loc":{"lines":{"from":312,"to":341}}}}},{"id":"3f94d722-fe93-404f-b00e-c3d9175655c1","payload":{"content":"Lab 4: C-Program to implement Lexical Analyzer in C \n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <ctype.h> \nint isKeyword(char buffer[]) \n{ \n    char keywords[32][10] = {\"auto\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \n                             \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\", \"for\", \"goto\", \n                             \"if\", \"int\", \"long\", \"register\", \"return\", \"short\", \"signed\", \n                             \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\", \"union\", \n                             \"unsigned\", \"void\", \"volatile\", \"while\"}; \n    int i, flag = 0; \n    for (i = 0; i < 32; ++i) \n    { \n        if (strcmp(keywords[i], buffer) == 0) \n        { \n            flag = 1; \n            break; \n        } \n    } \n    return flag; \n} \nint main() \n{ \n    char ch, buffer[15], operators[] = \"+-*/%=\"; \n    FILE *fp; \n    int i, j = 0; \n    fp = fopen(\"input1.txt\", \"r\");","metadata":{"loc":{"lines":{"from":202,"to":230}}}}},{"id":"47fd70e8-db5a-4b66-b52f-cf78fdf2683f","payload":{"content":"while (productionSet[i][j] != '\\0') \n                { \n                    foundEpsilon = 0; \n                    FIRST(subResult, productionSet[i][j]); \n                    for (k = 0; subResult[k] != '\\0'; k++) \n                        addToResultSet(Result, subResult[k]); \n                    for (k = 0; subResult[k] != '\\0'; k++) \n                    { \n                        if (subResult[k] == '$') \n                        { \n                            foundEpsilon = 1; \n                            break; \n                        } \n                    } \n                    // No e found, no need to check next element \n                    if (!foundEpsilon) \n                        break; \n                    j++; \n                } \n            } \n        } \n    } \n    return; \n} \nvoid addToResultSet(char Result[], char val) \n{ \n    int k; \n    for (k = 0; Result[k] != '\\0'; k++) \n        if (Result[k] == val) \n            return;","metadata":{"loc":{"lines":{"from":344,"to":373}}}}},{"id":"60ea1522-68ac-41e3-bbb6-58ba53c41b90","payload":{"content":"if (a[k][0] == c) \n        { \n            if (a[k][2] == '#' && c != a[i][0]) \n                follow(R, a[i][0]); \n            else if ((!(isupper(a[k][2]))) && a[k][2] != '#') \n                addToResultSet(R, a[k][2]); \n            else \n                first(R, a[k][2]); \n            for (m = 0; R[m] != '\\0'; m++) \n                addToResultSet(Result, R[m]); \n        } \n    } \n} \nvoid addToResultSet(char Result[], char val) \n{ \n    int k; \n    for (k = 0; Result[k] != '\\0'; k++) \n        if (Result[k] == val) \n            return; \n    Result[k] = val; \n    Result[k + 1] = '\\0'; \n} \nOutput:","metadata":{"loc":{"lines":{"from":461,"to":483}}}}},{"id":"6b2a0586-947c-4136-9515-c2271b5f997c","payload":{"content":"printf(\" }\\n\"); \n        printf(\"Do you want to continue(Press 1 to continue....)?\"); \n        scanf(\"%d\", &choice); \n    } while (choice == 1); \n} \nvoid follow(char *Result, char c) \n{ \n    int k; \n    subResult[0] = '\\0'; \n    Result[0] = '\\0'; \n    if (a[0][0] == c) \n        addToResultSet(Result, '$'); \n    for (i = 0; i < n; i++) \n    { \n        for (j = 2; j < strlen(a[i]); j++) \n        { \n            if (a[i][j] == c) \n            { \n                if (a[i][j + 1] != '\\0') \n                    first(subResult, a[i][j + 1]); \n                if (a[i][j + 1] == '\\0' && c != a[i][0]) \n                    follow(subResult, a[i][0]); \n                for (k = 0; subResult[k] != '\\0'; k++) \n                    addToResultSet(Result, subResult[k]) \n    } \n} \nvoid first(char *R, char c) \n{ \n    int k, m; \n    if (!(isupper(c)) && c != '#') \n        addToResultSet(R, c); \n    for (k = 0; k < n; k++){","metadata":{"loc":{"lines":{"from":427,"to":458}}}}},{"id":"79b97438-9d7c-48a0-b50a-b72f3767ab9f","payload":{"content":"} \nvoid explore() \n{ \n    i = 1; \n    while (k[i].op != '\\0') \n    { \n        fleft(k[i].pos); \n        fright(k[i].pos); \n        str[k[i].pos] = tmpch--; \n        printf(\"\\t%c := %s%c%s\\t\\t\", str[k[i].pos], left, k[i].op, right); \n        for (j = 0; j < strlen(str); j++) \n            if (str[j] != '$') \n                printf(\"%c\", str[j]); \n        printf(\"\\n\"); \n        i++; \n    } \n    fright(-1); \n    if (no == 0) \n    { \n        fleft(strlen(str)); \n        printf(\"\\t%s := %s\", right, left); \n        exit(0); \n    } \n    printf(\"\\t%s := %c\", right, str[k[--i].pos]); \n} \nvoid fleft(int x) \n{ \n    int w = 0, flag = 0; \n    x--;","metadata":{"loc":{"lines":{"from":755,"to":783}}}}},{"id":"7c2bb3c9-45f6-4ee3-9d5e-1ec52ad608f1","payload":{"content":"Lab 7: Write a C program for constructing of LL (1) parsing \n#include <stdio.h> \n#include <string.h> \n#include <process.h> \nchar s[20], stack[20]; \nint main() \n{ \n    char m[5][6][4] = {\"tb\", \" \", \" \", \"tb\", \" \", \" \", \" \", \"+tb\", \" \", \" \", \"n\", \"n\", \"fc\", \" \", \" \", \"fc\", \" \", \n\" \", \" \", \"n\", \"*fc\", \" a\", \"n\", \"n\", \"i\", \" \", \" \", \"(e)\", \" \", \" \"}; \n    int size[5][6] = {2, 0, 0, 2, 0, 0, 0, 3, 0, 0, 1, 1, 2, 0, 0, 2, 0, 0, 0, 1, 3, 0, 1, 1, 1, 0, 0, 3, 0, 0}; \n    int i, j, k, n, str1, str2; \n    printf(\"\\n Enter the input string: \"); \n    scanf(\"%s\", s); \n    strcat(s, \"$\"); \n    n = strlen(s); \n    stack[0] = '$'; \n    stack[1] = 'e'; \n    i = 1; \n    j = 0; \n    printf(\"\\nStack Input\\n\"); \n    printf(\"__________________\\n\"); \n    while ((stack[i] != '$') && (s[j] != '$')) \n    { \n        if (stack[i] == s[j]) \n        { \n            i--; \n            j++; \n        } \n        switch (stack[i])","metadata":{"loc":{"lines":{"from":489,"to":517}}}}},{"id":"90dec971-5cf2-439e-b581-61fe1f23cf2d","payload":{"content":"} \n  if (strcmp(op, \"=\") == 0) \n        { \n            fprintf(fp2, \"\\n MOV R0,%s\", arg1); \n            fprintf(fp2, \"\\n MOV %s,R0\", result);} \nfclose(fp1); \nfclose(fp2); \nreturn 0; \n} \nInput: \n \nOutput:","metadata":{"loc":{"lines":{"from":874,"to":885}}}}},{"id":"95e009b1-c67f-4686-a63b-3d18dc76b696","payload":{"content":"{ \n            k[j].pos = i; \n            k[j++].op = ':'; \n        } \n    for (i = 0; str[i] != '\\0'; i++) \n        if (str[i] == '/') \n        { \n            k[j].pos = i; \n            k[j++].op = '/'; \n        } \n    for (i = 0; str[i] != '\\0'; i++) \n        if (str[i] == '*') \n        { \n            k[j].pos = i; \n            k[j++].op = '*'; \n        } \n    for (i = 0; str[i] != '\\0'; i++) \n        if (str[i] == '+') \n        { \n            k[j].pos = i; \n            k[j++].op = '+'; \n        } \n    for (i = 0; str[i] != '\\0'; i++) \n    { \n        if (str[i] == '-') \n        { \n            k[j].pos = i; \n            k[j++].op = '-'; \n        } \n    }","metadata":{"loc":{"lines":{"from":723,"to":752}}}}},{"id":"a2fa38ed-ed55-4354-9f4f-afdca486f148","payload":{"content":"printf(\"%c\", s[k]); \n        printf(\" \\n \"); \n    } \n    printf(\"\\n SUCCESS\"); \n    return 0; \n} \n \nOutput:  \n \n \n \n \n \n \n \n\n \nLab 8: C Program to Implement Shift Reduce Parser \n#include <stdio.h> \n#include <stdlib.h> \n#include <conio.h> \n#include <string.h> \nchar ip_sym[15], stack[15]; \nint ip_ptr = 0, st_ptr = 0, len, i; \nchar temp[2], temp2[2]; \nchar act[15]; \nvoid check(); \nint main() \n{ \n    printf(\"\\n\\t\\t SHIFT REDUCE PARSER\\n\"); \n    printf(\"\\n GRAMMER\\n\"); \n    printf(\"\\n E->E+E\\n E->E/E\"); \n    printf(\"\\n E->E*E\\n E->a/b\"); \n    printf(\"\\n enter the input symbol:\\t\"); \n    gets(ip_sym); \n    printf(\"\\n\\t stack implementation table\"); \n    printf(\"\\n stack\\t\\t input symbol\\t\\t action\"); \n    printf(\"\\n______\\t\\t ____________\\t\\t ______\\n\"); \n    printf(\"\\n $\\t\\t%s$\\t\\t\\t--\", ip_sym); \n    strcpy(act, \"shift \"); \n    temp[0] = ip_sym[ip_ptr]; \n    temp[1] = '\\0'; \n    strcat(act, temp); \n    len = strlen(ip_sym); \n    for (i = 0; i <= len - 1; i++) \n    {","metadata":{"loc":{"lines":{"from":584,"to":629}}}}},{"id":"a7181f05-784e-4311-a977-67c5c2263c1c","payload":{"content":"while (x != -1 && str[x] != '+' && str[x] != '*' && str[x] != '=' && str[x] != '\\0' && str[x] != \n'-' && str[x] != '/' && str[x] != ':') \n    { \n        if (str[x] != '$' && flag == 0) \n        { \n            left[w++] = str[x]; \n            left[w] = '\\0'; \n            str[x] = '$'; \n            flag = 1; \n        } \n        x--; \n    } \n} \nvoid fright(int x) \n{ \n    int w = 0, flag = 0; \n    x++; \n    while (x != -1 && str[x] != '+' && str[x] != '*' && str[x] != '\\0' && \n           str[x] != '=' && str[x] != ':' && str[x] != '-' && str[x] != '/') \n    { \n        if (str[x] != '$' && flag == 0) \n        { \n            right[w++] = str[x]; \n            right[w] = '\\0'; \n            str[x] = '$'; \n            flag = 1; \n        } \n        x++; \n    } \n} \n\n \nOutput:","metadata":{"loc":{"lines":{"from":786,"to":818}}}}},{"id":"afe87798-444a-460a-accf-e568afefb45b","payload":{"content":"Lab 1: Write program in C to test whether given entered string within valid \ncomment section or not.  \n \n #include <stdio.h> \n#include <conio.h> \nint main() \n{ \n    char com[30]; \n    int i = 2, a = 0; \n    printf(\"\\n Enter comment:\"); \n    // fgets(com,sizeof(com),stdin); \n    gets(com); \n    if (com[0] == '/') \n    { \n        if (com[1] == '/') \n            printf(\"\\n It is a comment\"); \n        else if (com[1] == '*') \n        { \n            for (i = 2; i <= 30; i++) \n            { \n                if (com[i] == '*' && com[i + 1] == '/') \n                { \n                    printf(\"\\n It is a comment\"); \n                    a = 1; \n                    break; \n                } \n                else \n                    continue; \n            }","metadata":{"loc":{"lines":{"from":1,"to":29}}}}},{"id":"b0516e80-90ba-4ff4-8bd6-b059472d4dd5","payload":{"content":"break; \n            case 2: \n                if (c == 'b') \n                    state = 2; \n                else \n                    state = 6; \n                break; \n            case 4: \n                if (c == 'b') \n                    state = 5; \n                else \n                    state = 6; \n                break; \n            case 5: \n                if (c == 'b') \n                    state = 2; \n                else \n                    state = 6; \n                break; \n            case 6: \n                printf(\"\\n%s is not recognized\", s); \n                exit(0); \n        } \n    } \n    if (state == 0 || state == 1) \n        printf(\"\\n%s is accepted under rule 'a*'\", s); \n    else if (state == 2 || state == 4) \n        printf(\"\\n%s is accepted under rule 'a*b+'\", s); \n    else if (state == 5) \n        printf(\"\\n%s is accepted under rule 'abb'\", s);","metadata":{"loc":{"lines":{"from":89,"to":118}}}}},{"id":"b977a7e3-df2d-4cb8-8c93-95e7bac469e8","payload":{"content":"if (a == 0) \n                printf(\"\\n It is not a comment\"); \n        } \n        else \n            printf(\"\\n It is not a comment\"); \n    } \n    else \n        printf(\"\\n It is not a comment\"); \n    return 0; \n} \nOutput:","metadata":{"loc":{"lines":{"from":32,"to":42}}}}},{"id":"c4a45941-3959-4492-ac33-d36e77ebddc1","payload":{"content":"Lab 9: C-program for intermediate Code Generation \n \n#include <stdio.h> \n#include <string.h> \n#include <process.h> \nint i = 1, j = 0, no = 0, tmpch = 90; \nchar str[100], left[15], right[15]; \nvoid findopr(); \nvoid explore(); \nvoid fleft(int); \nvoid fright(int); \nstruct exp \n{ \n    int pos; \n    char op; \n} k[15]; \nint main() \n{ \n    printf(\"\\t\\t INTERMEDIATE CODE GENERATION\\n\\n\"); \n    printf(\"Enter the Expression :\"); \n    scanf(\"%s\", str); \n    printf(\"The intermediate code:\\t\\t Expression\\n\"); \n    findopr(); \n    explore(); \n    return 0; \n} \nvoid findopr() \n{ \n    for (i = 0; str[i] != '\\0'; i++) \n        if (str[i] == ':')","metadata":{"loc":{"lines":{"from":691,"to":720}}}}},{"id":"c5deea28-32d5-4d45-8a63-8468949d4b79","payload":{"content":"Lab 2: Write a C program to recognize strings under 'a*', 'a*b+', 'abb' \n \n#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \nint main() { \n    char s[100], c; \n    int state = 0, i = 0; \n    printf(\"\\nEnter a string: \"); \n    fgets(s, sizeof(s), stdin); \n    s[strcspn(s, \"\\n\")] = '\\0';  \n    while (s[i] != '\\0') { \n        c = s[i++]; \n        switch (state) { \n            case 0: \n                if (c == 'a') \n                    state = 1; \n                else if (c == 'b') \n                    state = 2; \n                else \n                    state = 6; \n                break; \n            case 1: \n                if (c == 'a') \n                    state = 1; \n                else if (c == 'b') \n                    state = 4; \n                else \n                    state = 6;","metadata":{"loc":{"lines":{"from":58,"to":86}}}}},{"id":"cc2ca6f6-223b-4f8a-8eab-6076bc8f3733","payload":{"content":"if ((!strcmpi(temp2, \"+\")) || (strcmpi(temp2, \"*\")) || (!strcmpi(temp2, \"/\"))) \n    { \n        flag = 1; \n    } \n    if ((!strcmpi(stack, \"E+E\")) || (!strcmpi(stack, \"E\\E\")) || (!strcmpi(stack, \"E*E\"))) \n    { \n        strcpy(stack, \"E\"); \n        st_ptr = 0; \n        if (!strcmpi(stack, \"E+E\")) \n            printf(\"\\n $%s\\t\\t%s$\\t\\t\\tE->E+E\", stack, ip_sym) \n    } \n    if (!strcmpi(stack, \"E\") && ip_ptr == len) \n    { \n        printf(\"\\n $%s\\t\\t%s$\\t\\t\\tACCEPT\", stack, ip_sym); \n        getch(); \n        exit(0); \n    } \n    if (flag == 0) \n    { \n        printf(\"\\n%s\\t\\t\\t%s\\t\\t reject\", stack, ip_sym); \n        exit(0); \n    } \n} \nOutput:","metadata":{"loc":{"lines":{"from":664,"to":687}}}}},{"id":"dbb417e4-89da-48bb-8889-58f10cbab5a7","payload":{"content":"break; \n        case ')': \n            str2 = 4; \n            break; \n        case '$': \n            str2 = 5; \n            break; \n        } \n        if (m[str1][str2][0] == '\\0') \n        { \n            printf(\"\\nERROR\"); \n            exit(0); \n        } \n        else if (m[str1][str2][0] == 'n') \n            i--; \n        else if (m[str1][str2][0] == 'i') \n            stack[i] = 'i'; \n        else \n        { \n            for (k = size[str1][str2] - 1; k >= 0; k--) \n            { \n                stack[i] = m[str1][str2][k]; \n                i++; \n            } \n            i--; \n        } \n        for (k = 0; k <= i; k++) \n            printf(\" %c\", stack[k]); \n        printf(\" \"); \n        for (k = j; k <= n; k++) \n\n \n            printf(\"%c\", s[k]); \n        printf(\" \\n \"); \n    } \n    printf(\"\\n SUCCESS\"); \n    return 0; \n} \n \nOutput:","metadata":{"loc":{"lines":{"from":552,"to":591}}}}},{"id":"e8287d24-df58-4c16-9b80-6e8addef6e20","payload":{"content":"stack[st_ptr] = ip_sym[ip_ptr]; \n        stack[st_ptr + 1] = '\\0'; \n        ip_sym[ip_ptr] = ' '; \n        ip_ptr++; \n        printf(\"\\n $%s\\t\\t%s$\\t\\t\\t%s\", stack, ip_sym, act); \n        strcpy(act, \"shift \"); \n        temp[0] = ip_sym[ip_ptr]; \n        temp[1] = '\\0'; \n        strcat(act, temp); \n        check(); \n        st_ptr++; \n    } \n    st_ptr++; \n    check(); \n    return 0; \n} \nvoid check() \n{ \n    int flag = 0; \n    temp2[0] = stack[st_ptr]; \n    temp2[1] = '\\0'; \n    if ((!strcmpi(temp2, \"a\")) || (!strcmpi(temp2, \"b\"))) \n    { \n        stack[st_ptr] = 'E'; \n        if (!strcmpi(temp2, \"a\")) \n            printf(\"\\n $%s\\t\\t%s$\\t\\t\\tE->a\", stack, ip_sym); \n        else \n            printf(\"\\n $%s\\t\\t%s$\\t\\t\\tE->b\", stack, ip_sym); \n        flag = 1; \n    }","metadata":{"loc":{"lines":{"from":632,"to":661}}}}},{"id":"f3c3cadd-eb79-463c-8b3a-1c31c47be9c6","payload":{"content":"if (fp == NULL) \n    { \n        printf(\"error while opening the file\\n\"); \n        exit(0); \n    } \n    while ((ch = fgetc(fp)) != EOF) \n    { \n        for (i = 0; i < 6; ++i) \n        { \n            if (ch == operators[i]) \n                printf(\"%c is operator\\n\", ch); \n        } \n        if (isalnum(ch)) \n        { \n            buffer[j++] = ch; \n        } \n        else if ((ch == ' ' || ch == '\\n') && (j != 0)) \n        { \n            buffer[j] = '\\0'; \n            j = 0; \n            if (isKeyword(buffer) == 1) \n                printf(\"%s is keyword\\n\", buffer); \n            else \n                printf(\"%s is identifier\\n\", buffer); \n        } \n    } \n    fclose(fp); \n    return 0; \n} \nInput: \n\n \n \n \nOutput:","metadata":{"loc":{"lines":{"from":233,"to":267}}}}}],"next_page_offset":null},"status":"ok","time":0.000614958}